"""
üåê Agentic AI System - Web Interface
Modern Flask-based control panel for multi-agent system

Made with ‚ù§Ô∏è by Mulky Malikul Dhaher in Indonesia üáÆüá©
"""

from flask import Flask, render_template, request, jsonify, session
from flask_socketio import SocketIO, emit
import json
import sys
import os
import asyncio
from datetime import datetime
import threading
import time
from pathlib import Path

# Add parent directory to path
sys.path.append(str(Path(__file__).parent.parent))

app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'agentic-ai-system-secret-key-indonesia')
socketio = SocketIO(app, cors_allowed_origins="*")

# This function will read the system status from the file generated by start_agi_force.py
def get_live_system_status():
    """Reads the live system status from the JSON file."""
    status_file = Path(__file__).parent.parent / 'data' / 'system_status.json'
    if not status_file.exists():
        return {
            "status": "offline",
            "working_agents": {},
            "core_components": [],
            "version": "unknown"
        }
    try:
        with open(status_file, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return {
            "status": "error_reading_status",
            "working_agents": {},
            "core_components": [],
            "version": "unknown"
        }

@app.route('/')
def index():
    """Main dashboard"""
    return render_template('enhanced_index.html')

@app.route('/dashboard')
def dashboard():
    """Ultimate AGI Force Dashboard"""
    return render_template('dashboard.html')

@app.route('/agents')
def agents_page():
    """Agents management page"""
    return render_template('agents.html')

@app.route('/workflows')
def workflows():
    """Workflows management page"""
    return render_template('workflows.html')

@app.route('/monitoring')
def monitoring():
    """System monitoring page"""
    return render_template('monitoring.html')

@app.route('/platform_integrations')
def platform_integrations():
    """Platform integrations page"""
    return render_template('platform_integrations.html')

@app.route('/credentials')
def credentials():
    """Credential management page"""
    return render_template('credentials.html')

# API Routes
@app.route('/api/system/status')
def get_system_status():
    """Get current system status"""
    try:
        # Get status from prompt master if available
        if 'prompt_master' in agents_registry:
            master_status = agents_registry['prompt_master'].get_system_status()
            
            return jsonify({
                'success': True,
                'data': {
                    'system_status': 'running',
                    'agents_active': len([a for a in agents_registry.values() if hasattr(a, 'status') and a.status == 'ready']),
                    'total_agents': len(agents_registry),
                    'uptime': master_status.get('uptime', '0'),
                    'memory_usage': master_status.get('memory_usage', 'Unknown'),
                    'cpu_usage': '< 25%',
                    'last_update': datetime.now().isoformat(),
                    'version': '2.0.0',
                    'llm_providers': len(llm_gateway.providers) if llm_gateway else 0
                }
            })
        else:
            return jsonify({
                'success': True,
                'data': {
                    'system_status': 'partial',
                    'agents_active': len(agents_registry),
                    'total_agents': len(agents_registry),
                    'message': 'System running in basic mode'
                }
            })
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/agents/list')
def list_agents():
    """List all agents from the live system status."""
    try:
        live_status = get_live_system_status()
        agents_dict = live_status.get('working_agents', {})
        
        # The dictionary already contains the agent info, just convert it to a list
        agents_list = list(agents_dict.values())
        
        return jsonify({
            'success': True,
            'data': agents_list
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/agents/<agent_id>/status')
def get_agent_status(agent_id):
    """Get specific agent status"""
    try:
        if agent_id not in agents_registry:
            return jsonify({
                'success': False,
                'error': 'Agent not found'
            }), 404
        
        agent = agents_registry[agent_id]
        
        # Try to get performance metrics
        if hasattr(agent, 'get_performance_metrics'):
            status = agent.get_performance_metrics()
        else:
            status = {
                'agent_id': agent_id,
                'name': getattr(agent, 'name', agent_id),
                'status': getattr(agent, 'status', 'ready'),
                'capabilities': getattr(agent, 'capabilities', [])
            }
        
        return jsonify({
            'success': True,
            'data': status
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/task/submit', methods=['POST'])
def submit_task():
    """Submit a task to an agent via the file-based task queue."""
    try:
        data = request.get_json()
        agent_id = data.get('agent_id')
        task_data = data.get('task', {})

        if not agent_id or not task_data:
            return jsonify({'success': False, 'error': 'agent_id and task are required'}), 400

        # Create a unique task ID
        task_id = f"task_{datetime.now().strftime('%Y%m%d_%H%M%S%f')}_{agent_id}"
        
        task_payload = {
            'task_id': task_id,
            'agent_id': agent_id,
            'task_data': task_data,
            'submitted_at': datetime.now().isoformat(),
            'status': 'pending'
        }

        # Write the task to the queue directory
        task_queue_dir = Path(__file__).parent.parent / 'data' / 'task_queue'
        task_queue_dir.mkdir(exist_ok=True)
        task_file_path = task_queue_dir / f"{task_id}.json"
        
        with open(task_file_path, 'w') as f:
            json.dump(task_payload, f, indent=2)

        return jsonify({
            'success': True,
            'message': 'Task submitted to queue successfully.',
            'task_id': task_id
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/prompt/process', methods=['POST'])
def process_prompt():
    """Process a prompt through the system"""
    try:
        data = request.get_json()
        prompt = data.get('prompt', '')
        input_type = data.get('input_type', 'text')
        metadata = data.get('metadata', {})
        
        if not prompt:
            return jsonify({
                'success': False,
                'error': 'Prompt is required'
            }), 400
        
        # Use prompt master if available
        if 'prompt_master' in agents_registry:
            prompt_master = agents_registry['prompt_master']
            
            if hasattr(prompt_master, 'process_prompt'):
                if asyncio.iscoroutinefunction(prompt_master.process_prompt):
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    result = loop.run_until_complete(
                        prompt_master.process_prompt(prompt, input_type, metadata)
                    )
                    loop.close()
                else:
                    result = prompt_master.process_prompt(prompt, input_type, metadata)
            else:
                result = {
                    'success': False,
                    'error': 'Prompt processing not implemented'
                }
        else:
            # Fallback: try to route to appropriate agent
            result = {
                'success': True,
                'message': 'Prompt received but prompt master not available',
                'prompt': prompt,
                'suggested_agents': list(agents_registry.keys())
            }
        
        return jsonify({
            'success': True,
            'data': result
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/llm/providers')
def get_llm_providers():
    """Get LLM provider status"""
    try:
        if llm_gateway:
            status = llm_gateway.get_provider_status()
            usage = llm_gateway.get_usage_summary()
            
            return jsonify({
                'success': True,
                'data': {
                    'providers': status,
                    'usage': usage
                }
            })
        else:
            return jsonify({
                'success': False,
                'error': 'LLM Gateway not available'
            }), 500
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/llm/test', methods=['POST'])
def test_llm_providers():
    """Test all LLM providers"""
    try:
        if not llm_gateway:
            return jsonify({
                'success': False,
                'error': 'LLM Gateway not available'
            }), 500
        
        # Run async test
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        test_results = loop.run_until_complete(llm_gateway.test_all_providers())
        loop.close()
        
        return jsonify({
            'success': True,
            'data': test_results
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/memory/stats')
def get_memory_stats():
    """Get memory bus statistics"""
    try:
        if memory_bus:
            stats = memory_bus.get_usage_stats()
            return jsonify({
                'success': True,
                'data': stats
            })
        else:
            return jsonify({
                'success': False,
                'error': 'Memory bus not available'
            }), 500
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

# WebSocket Events
@socketio.on('connect')
def handle_connect():
    """Handle client connection"""
    print(f'Client connected: {request.sid}')
    emit('connection_status', {
        'status': 'connected',
        'message': 'üß† Connected to Agentic AI System',
        'timestamp': datetime.now().isoformat(),
        'system_version': '2.0.0'
    })

@socketio.on('disconnect')
def handle_disconnect():
    """Handle client disconnection"""
    print(f'Client disconnected: {request.sid}')

@socketio.on('subscribe_updates')
def handle_subscribe_updates():
    """Subscribe to system updates"""
    from flask_socketio import join_room
    join_room('system_updates')
    emit('subscription_confirmed', {
        'message': 'Subscribed to system updates'
    })

@socketio.on('request_status_update')
def handle_status_request():
    """Handle status update request"""
    try:
        # Get current system status
        status_data = {
            'agents_count': len(agents_registry),
            'active_agents': len([a for a in agents_registry.values() if hasattr(a, 'status') and a.status == 'ready']),
            'system_status': 'running',
            'timestamp': datetime.now().isoformat()
        }
        
        emit('status_update', status_data)
        
    except Exception as e:
        emit('error', {
            'message': str(e),
            'timestamp': datetime.now().isoformat()
        })

# Background monitoring
def background_monitoring():
    """Background monitoring and updates"""
    while True:
        try:
            # Update system status
            global system_status
            system_status.update({
                'status': 'running',
                'agents_active': len([a for a in agents_registry.values() if hasattr(a, 'status') and a.status == 'ready']),
                'total_agents': len(agents_registry),
                'last_update': datetime.now().isoformat()
            })
            
            # Emit updates to subscribed clients
            socketio.emit('system_update', system_status, room='system_updates')
            
            time.sleep(10)  # Update every 10 seconds
            
        except Exception as e:
            print(f"Background monitoring error: {e}")
            time.sleep(30)

# Error handlers
@app.errorhandler(404)
def not_found(error):
    return jsonify({
        'success': False,
        'error': 'Not found'
    }), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({
        'success': False,
        'error': 'Internal server error'
    }), 500

if __name__ == '__main__':
    print("üöÄ Starting Agentic AI System Web Interface")
    print("üáÆüá© Made with ‚ù§Ô∏è by Mulky Malikul Dhaher in Indonesia")
    print(f"üìä Dashboard will be available at: http://localhost:{os.getenv('WEB_INTERFACE_PORT', 5000)}")
    print(f"ü§ñ Loaded {len(agents_registry)} agents")
    
    # Start background monitoring
    monitoring_thread = threading.Thread(target=background_monitoring, daemon=True)
    monitoring_thread.start()
    
    # Run the application
    port = int(os.getenv('WEB_INTERFACE_PORT', 5000))
    host = os.getenv('WEB_INTERFACE_HOST', '0.0.0.0')
    
    socketio.run(app, host=host, port=port, debug=True, allow_unsafe_werkzeug=True)
