"""
üåê Agentic AI System - Web Interface
Modern Flask-based control panel for multi-agent system

Made with ‚ù§Ô∏è by Mulky Malikul Dhaher in Indonesia üáÆüá©
"""

from flask import Flask, render_template, request, jsonify, session
from flask_socketio import SocketIO, emit
import json
import sys
import os
import asyncio
from datetime import datetime
import threading
import time
from pathlib import Path

# Add parent directory to path
sys.path.append(str(Path(__file__).parent.parent))

# Import system components
try:
    from agents import AGENTS_REGISTRY as agents_registry
    print("‚úÖ Agents registry loaded")
except ImportError:
    agents_registry = {}
    print("‚ö†Ô∏è Agents registry not available")

try:
    from connectors.llm_gateway import llm_gateway
    print("‚úÖ LLM Gateway loaded")
except ImportError:
    llm_gateway = None
    print("‚ö†Ô∏è LLM Gateway not available")

try:
    from core.memory_bus import memory_bus
    print("‚úÖ Memory Bus loaded")
except ImportError:
    memory_bus = None
    print("‚ö†Ô∏è Memory Bus not available")

try:
    from agents.camel_agent_integration import camel_agent
    print("‚úÖ Camel Agent loaded")
except ImportError:
    camel_agent = None
    print("‚ö†Ô∏è Camel Agent not available")

app = Flask(__name__)
app.config['SECRET_KEY'] = os.getenv('SECRET_KEY', 'agentic-ai-system-secret-key-indonesia')
socketio = SocketIO(app, cors_allowed_origins="*")

# Global system status
system_status = {
    'status': 'running',
    'agents_active': 0,
    'total_agents': 0,
    'last_update': datetime.now().isoformat(),
    'version': '7.0.0',
    'owner': 'Mulky Malikul Dhaher',
    'owner_id': '1108151509970001'
}

# This function will read the system status from the file generated by launcher.py
def get_live_system_status():
    """Reads the live system status from the JSON file."""
    status_file = Path(__file__).parent.parent / 'data' / 'system_status.json'
    if not status_file.exists():
        return {
            "status": "offline",
            "working_agents": {},
            "core_components": [],
            "version": "7.0.0"
        }
    try:
        with open(status_file, 'r') as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return {
            "status": "error_reading_status",
            "working_agents": {},
            "core_components": [],
            "version": "7.0.0"
        }

@app.route('/')
def index():
    """Main dashboard"""
    return render_template('enhanced_index.html')

@app.route('/dashboard')
def dashboard():
    """Ultimate AGI Force Dashboard"""
    return render_template('dashboard.html')

@app.route('/agents')
def agents_page():
    """Agents management page"""
    return render_template('agents.html')

@app.route('/workflows')
def workflows():
    """Workflows management page"""
    return render_template('workflows.html')

@app.route('/monitoring')
def monitoring():
    """System monitoring page"""
    return render_template('monitoring.html')

@app.route('/platform_integrations')
def platform_integrations():
    """Platform integrations page"""
    return render_template('platform_integrations.html')

@app.route('/credentials')
def credentials():
    """Credential management page"""
    return render_template('credentials.html')

@app.route('/camel_collaboration')
def camel_collaboration():
    """Camel AI Collaboration page"""
    return render_template('camel_collaboration.html')

# API Routes
@app.route('/api/system/status')
def get_system_status():
    """Get current system status"""
    try:
        live_status = get_live_system_status()
        
        # Get additional stats if components are available
        llm_status = {}
        if llm_gateway:
            try:
                llm_status = llm_gateway.get_usage_summary()
            except:
                llm_status = {'total_requests': 0, 'total_tokens': 0}
        
        camel_stats = {}
        if camel_agent:
            try:
                camel_stats = camel_agent.get_collaboration_stats()
            except:
                camel_stats = {'active_collaborations': 0}
        
        return jsonify({
            'success': True,
            'data': {
                'system_status': live_status.get('status', 'unknown'),
                'agents_active': len([a for a in live_status.get('working_agents', {}).values() if a.get('status') == 'active']),
                'total_agents': len(live_status.get('working_agents', {})),
                'uptime': 'active',
                'memory_usage': 'Normal',
                'cpu_usage': '< 25%',
                'last_update': datetime.now().isoformat(),
                'version': live_status.get('version', '7.0.0'),
                'owner': live_status.get('owner', 'Mulky Malikul Dhaher'),
                'owner_id': live_status.get('owner_id', '1108151509970001'),
                'llm_providers': len(llm_gateway.providers) if llm_gateway else 0,
                'llm_requests': llm_status.get('total_requests', 0),
                'llm_tokens': llm_status.get('total_tokens', 0),
                'camel_collaborations': camel_stats.get('active_collaborations', 0),
                'core_components': live_status.get('core_components', [])
            }
        })
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/agents/list')
def list_agents():
    """List all agents from the live system status."""
    try:
        live_status = get_live_system_status()
        agents_dict = live_status.get('working_agents', {})
        
        # Convert agents dictionary to list with additional metadata
        agents_list = []
        for agent_id, agent_info in agents_dict.items():
            agent_data = {
                'id': agent_id,
                'name': agent_info.get('name', agent_id),
                'status': agent_info.get('status', 'unknown'),
                'capabilities': agent_info.get('capabilities', []),
                'last_activity': agent_info.get('last_activity'),
                'is_camel_integrated': agent_id == 'camel_agent' or 'camel' in agent_id.lower()
            }
            agents_list.append(agent_data)
        
        return jsonify({
            'success': True,
            'data': agents_list
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/agents/<agent_id>/status')
def get_agent_status(agent_id):
    """Get specific agent status"""
    try:
        live_status = get_live_system_status()
        agents_dict = live_status.get('working_agents', {})
        
        if agent_id not in agents_dict:
            return jsonify({
                'success': False,
                'error': 'Agent not found'
            }), 404
        
        agent_info = agents_dict[agent_id]
        
        # Add enhanced status for camel agent
        if agent_id == 'camel_agent' and camel_agent:
            try:
                camel_stats = camel_agent.get_collaboration_stats()
                agent_info.update(camel_stats)
            except:
                pass
        
        return jsonify({
            'success': True,
            'data': agent_info
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/task/submit', methods=['POST'])
def submit_task():
    """Submit a task to an agent via the file-based task queue."""
    try:
        data = request.get_json()
        agent_id = data.get('agent_id')
        task_data = data.get('task', {})

        if not agent_id or not task_data:
            return jsonify({'success': False, 'error': 'agent_id and task are required'}), 400

        # Create a unique task ID
        task_id = f"task_{datetime.now().strftime('%Y%m%d_%H%M%S%f')}_{agent_id}"
        
        task_payload = {
            'task_id': task_id,
            'agent_id': agent_id,
            'task_data': task_data,
            'submitted_at': datetime.now().isoformat(),
            'status': 'pending',
            'submitted_via': 'web_interface'
        }

        # Write the task to the queue directory
        task_queue_dir = Path(__file__).parent.parent / 'data' / 'task_queue'
        task_queue_dir.mkdir(exist_ok=True)
        task_file_path = task_queue_dir / f"{task_id}.json"
        
        with open(task_file_path, 'w') as f:
            json.dump(task_payload, f, indent=2)

        return jsonify({
            'success': True,
            'message': 'Task submitted to queue successfully.',
            'task_id': task_id
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/camel/collaborate', methods=['POST'])
def start_camel_collaboration():
    """Start a Camel AI collaboration session"""
    try:
        if not camel_agent:
            return jsonify({
                'success': False,
                'error': 'Camel Agent not available'
            }), 500
        
        data = request.get_json()
        topic = data.get('topic', '')
        participants = data.get('participants', ['task_analyst', 'solution_architect'])
        complexity = data.get('complexity', 'medium')
        
        if not topic:
            return jsonify({
                'success': False,
                'error': 'Topic is required'
            }), 400
        
        # Create task for camel agent
        task_data = {
            'content': topic,
            'complexity': complexity,
            'participants': participants
        }
        
        # Run collaboration asynchronously
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        result = loop.run_until_complete(camel_agent.process_task(task_data))
        loop.close()
        
        return jsonify({
            'success': True,
            'data': result
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/camel/stats')
def get_camel_stats():
    """Get Camel AI collaboration statistics"""
    try:
        if not camel_agent:
            return jsonify({
                'success': False,
                'error': 'Camel Agent not available'
            }), 500
        
        stats = camel_agent.get_collaboration_stats()
        
        return jsonify({
            'success': True,
            'data': stats
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/prompt/process', methods=['POST'])
def process_prompt():
    """Process a prompt through the system"""
    try:
        data = request.get_json()
        prompt = data.get('prompt', '')
        input_type = data.get('input_type', 'text')
        metadata = data.get('metadata', {})
        use_camel = data.get('use_camel', False)
        
        if not prompt:
            return jsonify({
                'success': False,
                'error': 'Prompt is required'
            }), 400
        
        # Use Camel Agent for collaborative processing if requested
        if use_camel and camel_agent:
            task_data = {
                'content': prompt,
                'complexity': metadata.get('complexity', 'medium'),
                'participants': metadata.get('participants', ['solution_architect', 'implementation_expert'])
            }
            
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            result = loop.run_until_complete(camel_agent.process_task(task_data))
            loop.close()
            
            return jsonify({
                'success': True,
                'data': result,
                'processing_method': 'camel_collaboration'
            })
        
        # Use prompt master if available
        if 'prompt_master' in agents_registry:
            prompt_master = agents_registry['prompt_master']
            
            if hasattr(prompt_master, 'process_prompt'):
                if asyncio.iscoroutinefunction(prompt_master.process_prompt):
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)
                    result = loop.run_until_complete(
                        prompt_master.process_prompt(prompt, input_type, metadata)
                    )
                    loop.close()
                else:
                    result = prompt_master.process_prompt(prompt, input_type, metadata)
            else:
                result = {
                    'success': False,
                    'error': 'Prompt processing not implemented'
                }
        else:
            # Fallback: try to route to appropriate agent
            result = {
                'success': True,
                'message': 'Prompt received but prompt master not available',
                'prompt': prompt,
                'suggested_agents': list(agents_registry.keys()),
                'processing_method': 'fallback'
            }
        
        return jsonify({
            'success': True,
            'data': result
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/llm/providers')
def get_llm_providers():
    """Get LLM provider status"""
    try:
        if llm_gateway:
            status = llm_gateway.get_provider_status()
            usage = llm_gateway.get_usage_summary()
            
            return jsonify({
                'success': True,
                'data': {
                    'providers': status,
                    'usage': usage,
                    'gateway_status': llm_gateway.status
                }
            })
        else:
            return jsonify({
                'success': False,
                'error': 'LLM Gateway not available'
            }), 500
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/llm/test', methods=['POST'])
def test_llm_providers():
    """Test all LLM providers"""
    try:
        if not llm_gateway:
            return jsonify({
                'success': False,
                'error': 'LLM Gateway not available'
            }), 500
        
        # Run async test
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        test_results = loop.run_until_complete(llm_gateway.test_all_providers())
        loop.close()
        
        return jsonify({
            'success': True,
            'data': test_results
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/agents/<agent_id>/<action>', methods=['POST'])
def agent_action(agent_id, action):
    """Perform action on specific agent"""
    try:
        task_data = {
            'action': action,
            'timestamp': datetime.now().isoformat(),
            'requested_via': 'web_dashboard'
        }
        
        # Submit task to agent via task queue
        task_id = f"action_{datetime.now().strftime('%Y%m%d_%H%M%S%f')}_{agent_id}"
        task_payload = {
            'task_id': task_id,
            'agent_id': agent_id,
            'task_data': task_data,
            'submitted_at': datetime.now().isoformat(),
            'status': 'pending',
            'submitted_via': 'web_dashboard'
        }

        # Write the task to the queue directory
        task_queue_dir = Path(__file__).parent.parent / 'data' / 'task_queue'
        task_queue_dir.mkdir(exist_ok=True)
        task_file_path = task_queue_dir / f"{task_id}.json"
        
        with open(task_file_path, 'w') as f:
            json.dump(task_payload, f, indent=2)

        return jsonify({
            'success': True,
            'message': f'Action {action} submitted for agent {agent_id}',
            'task_id': task_id
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/system/emergency-stop', methods=['POST'])
def emergency_stop():
    """Emergency stop all agents"""
    try:
        # Create emergency stop task for all agents
        live_status = get_live_system_status()
        agents_dict = live_status.get('working_agents', {})
        
        stopped_agents = []
        for agent_id in agents_dict.keys():
            task_id = f"emergency_stop_{datetime.now().strftime('%Y%m%d_%H%M%S%f')}_{agent_id}"
            task_payload = {
                'task_id': task_id,
                'agent_id': agent_id,
                'task_data': {
                    'action': 'emergency_stop',
                    'priority': 'urgent',
                    'timestamp': datetime.now().isoformat()
                },
                'submitted_at': datetime.now().isoformat(),
                'status': 'pending',
                'submitted_via': 'emergency_dashboard'
            }

            task_queue_dir = Path(__file__).parent.parent / 'data' / 'task_queue'
            task_queue_dir.mkdir(exist_ok=True)
            task_file_path = task_queue_dir / f"{task_id}.json"
            
            with open(task_file_path, 'w') as f:
                json.dump(task_payload, f, indent=2)
            
            stopped_agents.append(agent_id)

        return jsonify({
            'success': True,
            'message': f'Emergency stop initiated for {len(stopped_agents)} agents',
            'stopped_agents': stopped_agents
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/system/restart-all', methods=['POST'])
def restart_all():
    """Restart all agents"""
    try:
        # Create restart task for all agents
        live_status = get_live_system_status()
        agents_dict = live_status.get('working_agents', {})
        
        restarted_agents = []
        for agent_id in agents_dict.keys():
            task_id = f"restart_{datetime.now().strftime('%Y%m%d_%H%M%S%f')}_{agent_id}"
            task_payload = {
                'task_id': task_id,
                'agent_id': agent_id,
                'task_data': {
                    'action': 'restart',
                    'timestamp': datetime.now().isoformat()
                },
                'submitted_at': datetime.now().isoformat(),
                'status': 'pending',
                'submitted_via': 'restart_dashboard'
            }

            task_queue_dir = Path(__file__).parent.parent / 'data' / 'task_queue'
            task_queue_dir.mkdir(exist_ok=True)
            task_file_path = task_queue_dir / f"{task_id}.json"
            
            with open(task_file_path, 'w') as f:
                json.dump(task_payload, f, indent=2)
            
            restarted_agents.append(agent_id)

        return jsonify({
            'success': True,
            'message': f'Restart initiated for {len(restarted_agents)} agents',
            'restarted_agents': restarted_agents
        })
        
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

@app.route('/api/memory/stats')
def get_memory_stats():
    """Get memory bus statistics"""
    try:
        if memory_bus:
            if hasattr(memory_bus, 'get_usage_stats'):
                stats = memory_bus.get_usage_stats()
            else:
                stats = {
                    'status': memory_bus.status,
                    'entries': len(memory_bus.data) if hasattr(memory_bus, 'data') else 0
                }
            return jsonify({
                'success': True,
                'data': stats
            })
        else:
            return jsonify({
                'success': False,
                'error': 'Memory bus not available'
            }), 500
            
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500

# WebSocket Events
@socketio.on('connect')
def handle_connect():
    """Handle client connection"""
    print(f'üåê Client connected: {request.sid}')
    emit('connection_status', {
        'status': 'connected',
        'message': 'üöÄ Connected to Ultimate AGI Force',
        'timestamp': datetime.now().isoformat(),
        'system_version': '7.0.0',
        'owner': 'Mulky Malikul Dhaher',
        'owner_id': '1108151509970001'
    })

@socketio.on('disconnect')
def handle_disconnect():
    """Handle client disconnection"""
    print(f'‚ùå Client disconnected: {request.sid}')

@socketio.on('subscribe_updates')
def handle_subscribe_updates():
    """Subscribe to system updates"""
    from flask_socketio import join_room
    join_room('system_updates')
    emit('subscription_confirmed', {
        'message': 'Subscribed to system updates',
        'room': 'system_updates'
    })

@socketio.on('request_status_update')
def handle_status_request():
    """Handle status update request"""
    try:
        live_status = get_live_system_status()
        
        # Get current system status
        status_data = {
            'agents_count': len(live_status.get('working_agents', {})),
            'active_agents': len([a for a in live_status.get('working_agents', {}).values() if a.get('status') == 'active']),
            'system_status': live_status.get('status', 'unknown'),
            'timestamp': datetime.now().isoformat(),
            'camel_active': camel_agent is not None,
            'llm_gateway_active': llm_gateway is not None
        }
        
        emit('status_update', status_data)
        
    except Exception as e:
        emit('error', {
            'message': str(e),
            'timestamp': datetime.now().isoformat()
        })

# Background monitoring
def background_monitoring():
    """Background monitoring and updates"""
    while True:
        try:
            live_status = get_live_system_status()
            
            # Update system status
            global system_status
            system_status.update({
                'status': live_status.get('status', 'unknown'),
                'agents_active': len([a for a in live_status.get('working_agents', {}).values() if a.get('status') == 'active']),
                'total_agents': len(live_status.get('working_agents', {})),
                'last_update': datetime.now().isoformat(),
                'camel_available': camel_agent is not None,
                'llm_gateway_available': llm_gateway is not None
            })
            
            # Emit updates to subscribed clients
            socketio.emit('system_update', system_status, room='system_updates')
            
            time.sleep(10)  # Update every 10 seconds
            
        except Exception as e:
            print(f"üî• Background monitoring error: {e}")
            time.sleep(30)

# Error handlers
@app.errorhandler(404)
def not_found(error):
    return jsonify({
        'success': False,
        'error': 'Not found'
    }), 404

@app.errorhandler(500)
def internal_error(error):
    return jsonify({
        'success': False,
        'error': 'Internal server error'
    }), 500

if __name__ == '__main__':
    print("üöÄ Starting Ultimate AGI Force Web Interface v7.0.0")
    print("üëë Owned by: Mulky Malikul Dhaher (1108151509970001)")
    print("üáÆüá© Made with ‚ù§Ô∏è in Indonesia")
    print(f"üìä Dashboard will be available at: http://localhost:{os.getenv('WEB_INTERFACE_PORT', 5000)}")
    print(f"ü§ñ Loaded {len(agents_registry)} agents")
    print(f"üê™ Camel Agent: {'‚úÖ Available' if camel_agent else '‚ùå Not Available'}")
    print(f"üß† LLM Gateway: {'‚úÖ Available' if llm_gateway else '‚ùå Not Available'}")
    print(f"üíæ Memory Bus: {'‚úÖ Available' if memory_bus else '‚ùå Not Available'}")
    
    # Start background monitoring
    monitoring_thread = threading.Thread(target=background_monitoring, daemon=True)
    monitoring_thread.start()
    
    # Run the application
    port = int(os.getenv('WEB_INTERFACE_PORT', 5000))
    host = os.getenv('WEB_INTERFACE_HOST', '0.0.0.0')
    
    socketio.run(app, host=host, port=port, debug=False, allow_unsafe_werkzeug=True)
